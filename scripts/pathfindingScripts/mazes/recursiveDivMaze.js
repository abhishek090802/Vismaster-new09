// This code is an implementation of a recursive division maze generation algorithm using JavaScript. The maze is generated by recursively dividing the grid into sub-regions and creating passages to connect them.

// Here's a breakdown of how the maze generation works:


async function recursiveDivMaze(bias) {
    inProgress = true;
    clearBoard(keepWalls = false);

    //Animate edge walls
    for (var i = 0; i < totalRows; i++) {
        for (var j = 0; j < totalCols; j++) {
            if (i == 0 || j == 0 || i == (totalRows - 1) || j == (totalCols - 1)) {
                cellsToAnimate.push([[i, j], "wall"]);
            }
        }
    }

    var walls = createVisited();
    var passages = createVisited();
    recursiveDivMazeHelper(1, (totalRows - 2), 1, (totalCols - 2), 2, (totalRows - 3), 2, (totalCols - 3), walls, passages, bias);
    await animateCells();
    inProgress = false;
    return;
}


function recursiveDivMazeHelper(iStart, iEnd, jStart, jEnd, horzStart, horzEnd, vertStart, vertEnd, walls, passages, bias) {
    var height = iEnd - iStart + 1;
    var width = jEnd - jStart + 1;
    var canMakeVertWall = (vertEnd - vertStart) >= 0;
    var canMakeHorzWall = (horzEnd - horzStart) >= 0;
    if (height < 3 || width < 3 || !canMakeVertWall | !canMakeHorzWall) {
        return;
    }

// The recursiveDivMaze function is the entry point. It initializes the maze generation process and sets up the edge walls.

// The recursiveDivMazeHelper function is the recursive function responsible for dividing the maze and creating passages.


    // Choose line orientation
    var x = Math.floor(Math.random() * 10);
    if (bias == "VERTICAL") {
        var lineOrientation = x < 8 ? "VERTICAL" : "HORIZONTAL"; // weighting: 90/10 (V/H)
    } else if (bias == "HORIZONTAL") {
        var lineOrientation = x < 1 ? "VERTICAL" : "HORIZONTAL"; // weighting: 10/90 (V/H)
    } else {
        var lineOrientation = x < 5 ? "VERTICAL" : "HORIZONTAL"; // weighting: 50/50 (V/H)
    }

// The lineOrientation variable determines whether the current iteration will create a vertical or horizontal division line. The bias parameter can be used to control the bias towards vertical or horizontal divisions.

// The function calculates the available space for vertical and horizontal division lines and checks if it is feasible to create new walls in both directions.

// Depending on the lineOrientation, the function chooses a random row or column for the division line and creates passages to connect the regions on both sides of the line.



    // Draw line and create random passage
    if (lineOrientation == "VERTICAL") {
        var vertWidth = vertEnd - vertStart + 1;
        var randCol = Math.floor(Math.random() * vertWidth) + vertStart;
        if (passages[iStart][randCol]) {
            var randRow = iStart;
        } else if (passages[iEnd][randCol]) {
            var randRow = iEnd;
        } else {
            var randRow = (Math.floor(Math.random() * 2) == 0) ? iStart : iEnd; // random end assignment
            //var randRow = Math.floor(Math.random() * height) + iStart; // random parition
        }
        for (var i = iStart; i <= iEnd; i++) {
            if (passages[i][randCol]) { continue; }
            if (i == randRow) {
                // Make passages
                for (var j = randCol - 1; j <= randCol + 1; j++) {
                    passages[i][j] = true;
                }
            } else {
                walls[i][randCol] = true;
                cellsToAnimate.push([[i, randCol], "wall"]);
            }
        }
        recursiveDivMazeHelper(iStart, iEnd, jStart, (randCol - 1), horzStart, horzEnd, vertStart, (randCol - 2), walls, passages); //left
        recursiveDivMazeHelper(iStart, iEnd, (randCol + 1), jEnd, horzStart, horzEnd, (randCol + 2), vertEnd, walls, passages); //right
    } else {
        var horzHeight = horzEnd - horzStart + 1;
        var randRow = Math.floor(Math.random() * horzHeight) + horzStart;
        if (passages[randRow][jStart]) {
            var randCol = jStart;
        } else if (passages[randRow][jEnd]) {
            var randCol = jEnd;
        } else {
            var randCol = (Math.floor(Math.random() * 2) == 0) ? jStart : jEnd; // random end assignment
            //var randCol = Math.floor(Math.random() * width) + jStart; // random parition
        }
        for (var j = jStart; j <= jEnd; j++) {
            if (passages[randRow][j]) { continue; }
            if (j == randCol) {
                // Make passages
                for (var i = randRow - 1; i <= randRow + 1; i++) {
                    passages[i][j] = true;
                }
            } else {
                walls[randRow][j] = true;
                cellsToAnimate.push([[randRow, j], "wall"]);
            }
        }
        recursiveDivMazeHelper(iStart, (randRow - 1), jStart, jEnd, horzStart, (randRow - 2), vertStart, vertEnd, walls, passages); //up
        recursiveDivMazeHelper((randRow + 1), iEnd, jStart, jEnd, (randRow + 2), horzEnd, vertStart, vertEnd, walls, passages); //down
    }
    return;
}

// The function then recursively calls itself to divide the sub-regions on both sides of the division line.

// The recursive process continues until the regions become too small to divide (height or width less than 3) or it is not possible to create walls in either direction.

// Finally, the animateCells function is called to animate the maze generation process.

// The cellsToAnimate array stores the cells that need to be animated during the maze generation.


// Note: The maze generation is designed to work with a grid, where cells can be either walls or passages. The createVisited function seems to create a 2D array to keep track of visited cells, and the clearBoard function is used to reset the grid, which is not provided in the code snippet.

// Keep in mind that this code snippet does not include the actual implementation of the animateCells function, and the totalRows and totalCols variables are also not defined in the provided code. For a complete working implementation, you would need to define these missing parts and integrate the maze generation code with the actual grid representation and visualization logic.
